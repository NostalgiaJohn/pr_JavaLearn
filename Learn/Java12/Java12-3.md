# 线程与进程

[toc]

## 线程状态

#### 六种线程状态

```
线程：
	如果按照java.lang.Thread.State枚举方式来考虑，一共提供了6种状态
```

| 状态                    | 导致状态的发生条件                                           |
| :---------------------- | :----------------------------------------------------------- |
| NEW(新建)               | 线程刚刚被创建，没有启动，没有调用start方法                  |
| RUNNABLE(可运行)        | 线程已经可以在JVM中运行，但是是否运行不确定，看当前线程是否拥有CPU执行权 |
| BLOCKED(锁阻塞)         | 当前线程进入一个同步代码需要获取对应的锁对象，但是发现当前锁对象被其他线程持有，当前线程会进入一个BLOCKED。如果占用锁对象的线程打开锁对象，当前线程持有对应锁对象，进入Runnable状态 |
| WAITING(无限等待)       | 通过一个wait方法线程进入一个无限等待状态，这里需要另外一个线程进行唤醒操作。进入无限等待状态的线程是无法自己回到Runnable状态，需要其他线程通过notify或者notifyAll方法进行唤醒操作 |
| TIMED_WAITING(计时等待) | 当前线程的确是等待状态，但是会在一定时间之后自动回到Runnable状态，例如 Thread.sleep() 或者是Object类内的wait(int ms); |
| TERMINATED(被终止)      | 因为Run方法运行结束正常退出线程，或者说在运行的过程中因为出现异常导致当前线程Over |

#### TIMED_WAITING(计时等待)

```
Thread.sleep(int ms);
	在对应线程代码块中，当前线程休眠指定的时间。
Object类内  wait(int ms);
	让当前线程进入一个计时等待状态
		1. 规定的时间计时完毕，线程回到可运行状态
		2. 在等待时间内，通过其他线程被notify或者notifyAll唤醒

Sleep方法
	1. 调用之后休眠指定时间
	2. sleep方法必须执行在run方法内，才可以休眠线程
	3. sleep不会打开当前线程占用的锁对象。
```

![TIMED_WAITING状态](https://i.loli.net/2021/06/06/KT4Z3QPt5MDqg9U.png)

#### BLOCKED(锁阻塞)

```
线程中有锁存在，线程需要进入带有锁操作的同步代码，如果锁对象被别人持有，只能在锁外等待

锁阻塞状态的线程是否能够抢到锁对象有很多因素
	1. 优先级问题，非决定因素
	2. CPU执行概率问题。

后期高并发一定会存在多线程操作锁对象问题：抢购...
	队列方式来处理
```

![BLOCKED阻塞状态](https://i.loli.net/2021/06/06/cuKOVm91H5dtLBo.png)

#### 线程状态 WAITING(无限等待)

```
当某一个线程被执行wait()方法，需要等待另外的一个线程进行唤醒操作。

一下三个方法都是Object类内的方法:
	public void wait();
		在哪一个线程中执行，就会让当前线程进入一个无限等待状态。
			1. 所在线程进入无限等待状态
			2. 开启【锁对象】
	
	public void notify();
		唤醒和当前锁对象有关的无限等待线程中的一个，随机选择。
			1. 唤醒一个无限等待状态线程
			2. 开启【锁对象】
	
	public void notifyAll();
		唤醒所有和当前锁对象有关的无限等待线程
			1. 唤醒所有线程
			2. 开启【锁对象】
			3. 线程进入锁对象抢占过程，就有可能进入一个锁阻塞状态。
```

![无限等待图例](https://i.loli.net/2021/06/09/eRIF1CuzgA2VnOc.png)

#### 线程执行的所有状态分析图

![六大线程状态](https://i.loli.net/2021/06/09/OInc96SfBKlrUHy.png)





#### 5. 作业

![](D:/ProgramLearning/B站Java-NZGP/Day21-多线程，同步/img/多线程问题.png)

```
1. 这里有5个线程类，完全不一样，如果完成一个锁对象操作以上五个线程
2. 测试线程优先级和执行概率问题
	一个优先级为10的线程和优先级为1的线程，执行结果保存到文件
3. OA打卡功能
	1. 9~18打卡
	2. 打卡间隔不得超过2小时
	3. 打卡记录保存到文件，异常文件中要有展示
4. LRC歌词解析
	手动播放歌曲，Java程序解析歌词展示
	字符串练习和集合练习
```







